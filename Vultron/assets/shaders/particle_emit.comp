#version 460

layout(set = 0, binding = 0) uniform UniformBufferObject {
    mat4 view;
    mat4 proj;
    vec4 viewPosAndDeltaTime;
    vec4 lightDirAndRandom;
    vec3 lightColor;
    mat4 lightSpaceMatrix;
} ubo;

struct ParticleEmitterData
{
    vec4 positionAndLifeTime;
    vec3 lifeDurationAndNumFramesAndFrameRate;
    vec3 initialVelocity;
    vec3 acceleration;
    vec4 sizeAndSizeSpan;
    vec3 phiThetaSpanAndRotation;
    vec4 texCoordAndSize;
    vec4 startColor;
    vec4 endColor;
    vec4 numParticlesAndVelocitySpanAndTexSpan;
    vec4 scaleFadeInOutAndOpacityFadeInOut;
};

layout(std140, set = 0, binding = 1) readonly buffer ParticleEmitterBufferObject {
    ParticleEmitterData emitters[];
};

struct ParticleInstanceData {
    vec4 positionAndLifeTime;
    vec3 lifeDurationAndNumFramesAndFrameRate;
    vec3 sizeAndRotation;
    vec3 velocity;
    vec3 acceleration;
    vec4 texCoordAndSize;
    vec4 startColor;
    vec4 endColor;
    vec4 scaleFadeInOutAndOpacityFadeInOut;
};

layout(std140, set = 0, binding = 2) buffer ParticleInstanceBufferObject {
    uint instanceCount;
    ParticleInstanceData instances[];
};

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

uint hash(uint x) {
    x += (x << 10u);
    x ^= (x >> 6u);
    x += (x << 3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}

float random(uint seed) {
    return float(hash(seed) & 0xFFFFFFFu) / float(0x10000000u);
}

vec3 randomDirectionInCone(vec3 direction, float spreadTheta, float spreadPhi, uint seed) {
    float deltaTheta = spreadTheta * (2.0 * random(seed) - 1.0);
    float deltaPhi = spreadPhi * (2.0 * random(seed + 1u) - 1.0);
    
    mat3 rotationX = mat3(
        1.0, 0.0, 0.0,
        0.0, cos(deltaPhi), -sin(deltaPhi),
        0.0, sin(deltaPhi), cos(deltaPhi)
    );

    mat3 rotationY = mat3(
        cos(deltaTheta), 0.0, sin(deltaTheta),
        0.0, 1.0, 0.0,
        -sin(deltaTheta), 0.0, cos(deltaTheta)
    );

    return rotationY * rotationX * direction;
}

void main()  {
    int emitterIndex = int(gl_WorkGroupID.x);
    ParticleEmitterData emitter = emitters[emitterIndex];
    uint numParticles = uint(emitter.numParticlesAndVelocitySpanAndTexSpan.x);

    float thetaSpan = emitter.phiThetaSpanAndRotation.y;
    float phiSpan = emitter.phiThetaSpanAndRotation.x;

    for (uint i = 0; i < numParticles; i++) {
        ParticleInstanceData instance;
        instance.positionAndLifeTime = emitter.positionAndLifeTime;

        if (emitter.initialVelocity != vec3(0.0)) {  
            vec3 velocityDirection = normalize(emitter.initialVelocity);
            velocityDirection = randomDirectionInCone(velocityDirection, thetaSpan, phiSpan, instanceCount);
            vec3 velocity = normalize(velocityDirection) * (length(emitter.initialVelocity) + random(emitterIndex + i) * emitter.numParticlesAndVelocitySpanAndTexSpan.y);
            instance.velocity = velocity;
        } else {
            instance.velocity = emitter.initialVelocity;
        }

        instance.acceleration = emitter.acceleration;

        uvec2 seed = uvec2(instance.positionAndLifeTime.xy * 1000.0) + emitterIndex + i;
        vec2 texCoord = uvec2(vec2(random(seed.x), random(seed.y)) * emitter.numParticlesAndVelocitySpanAndTexSpan.zw) * emitter.texCoordAndSize.zw + emitter.texCoordAndSize.xy;
        instance.texCoordAndSize = vec4(texCoord, emitter.texCoordAndSize.z, emitter.texCoordAndSize.w);
        instance.sizeAndRotation.xy = emitter.sizeAndSizeSpan.xy + random(seed.x + 2u) * emitter.sizeAndSizeSpan.zw;
        instance.sizeAndRotation.z = emitter.phiThetaSpanAndRotation.z;
        instance.startColor = emitter.startColor;
        instance.endColor = emitter.endColor;

        instance.lifeDurationAndNumFramesAndFrameRate = emitter.lifeDurationAndNumFramesAndFrameRate;
        instance.scaleFadeInOutAndOpacityFadeInOut = emitter.scaleFadeInOutAndOpacityFadeInOut;
        
        uint instanceIndex = atomicAdd(instanceCount, 1);
        instances[instanceIndex] = instance;
    }

}