#version 450 core

// This shader implements a sorting network for 1024 elements.
//
// It is follows the alternative notation for bitonic sorting networks, as given at:
// https://en.m.wikipedia.org/wiki/Bitonic_sorter#Alternative_representation

// Note that there exist hardware limits - look these up for your GPU via https://vulkan.gpuinfo.org/
// sizeof(local_values[]) : Must be <= maxComputeSharedMemorySize
// local_size_x          : Must be <= maxComputeWorkGroupInvocations

// ENUM for uniform::Parameters.algorithm:
#define eLocalBitonicMergeSortExample   0
#define eLocalDisperse                  1
#define eBigFlip                        2
#define eBigDisperse                    3

layout(local_size_x = 128) in; // Set value for local_size_x via specialization constant with id 1

struct ParticleInstanceData {
    vec4 positionAndLifeTime;
    vec3 lifeDurationAndNumFramesAndFrameRate;
    vec3 sizeAndRotation;
    vec4 velocityAndGravityFactor;
    vec4 texCoordAndSize;
    vec4 startColor;
    vec4 endColor;
    vec4 scaleFadeInOutAndOpacityFadeInOut;
};

layout(std140, set = 0, binding = 0) buffer ParticleInstanceBufferObject {
    uint instanceCount;
    ParticleInstanceData values[];
};

// Push constants
layout(push_constant) uniform Parameters {
    uint h;
    uint algorithm;
    mat4 viewProjection;
} parameters;

// Workgroup local memory. We use this to minimise round-trips to global memory.
// It allows us to evaluate a sorting network of up to 1024 with one shader invocation.
shared ParticleInstanceData local_values[gl_WorkGroupSize.x * 2];
// shared uint local_indices[gl_WorkGroupSize.x * 2];

bool compare(in const ParticleInstanceData left, in const ParticleInstanceData right){
    
    if (left.positionAndLifeTime.w == 0) {
        return true;
    }
    
    if (right.positionAndLifeTime.w == 0) {
        return false;
    }

	float depthLeft = (parameters.viewProjection * vec4(left.positionAndLifeTime.xyz, 1.0)).z;
	float depthRight = (parameters.viewProjection * vec4(right.positionAndLifeTime.xyz, 1.0)).z;
    
    // Return comparison result for distance squared to camera
    // return distance(left.positionAndLifeTime.xyz, parameters.cameraPosition) < distance(right.positionAndLifeTime.xyz, parameters.cameraPosition);
	// return left.positionAndLifeTime.y > right.positionAndLifeTime.y;
	return depthLeft < depthRight;
}

void global_compare_and_swap(ivec2 idx){
	if (compare(values[idx.x], values[idx.y])) {
		ParticleInstanceData tmp = values[idx.x];
		values[idx.x] = values[idx.y];
		values[idx.y] = tmp;
	}
}

// Performs compare-and-swap over elements held in shared,
// workgroup-local memory
void local_compare_and_swap(ivec2 idx){
	// if (compare(local_values[idx.x], local_values[idx.y])) {
    if (compare(local_values[idx.x], local_values[idx.y])) {
		ParticleInstanceData tmp = local_values[idx.x];
		local_values[idx.x] = local_values[idx.y];
		local_values[idx.y] = tmp;

        // uint tmp_idx = local_indices[idx.x];
        // local_indices[idx.x] = local_indices[idx.y];
        // local_indices[idx.y] = tmp_idx;
	}
}

// Performs full-height flip (h height) over globally available indices.
void big_flip( in uint h) {

	uint t_prime = gl_GlobalInvocationID.x;
	uint half_h = h >> 1; // Note: h >> 1 is equivalent to h / 2 

	uint q       = ((2 * t_prime) / h) * h;
	uint x       = q     + (t_prime % half_h);
	uint y       = q + h - (t_prime % half_h) - 1; 


	global_compare_and_swap(ivec2(x,y));
}

// Performs full-height disperse (h height) over globally available indices.
void big_disperse( in uint h ) {

	uint t_prime = gl_GlobalInvocationID.x;

	uint half_h = h >> 1; // Note: h >> 1 is equivalent to h / 2 

	uint q       = ((2 * t_prime) / h) * h;
	uint x       = q + (t_prime % (half_h));
	uint y       = q + (t_prime % (half_h)) + half_h;

	global_compare_and_swap(ivec2(x,y));

}

// Performs full-height flip (h height) over locally available indices.
void local_flip(in uint h){
		uint t = gl_LocalInvocationID.x;
		barrier();

		uint half_h = h >> 1; // Note: h >> 1 is equivalent to h / 2 
		ivec2 indices = 
			ivec2( h * ( ( 2 * t ) / h ) ) +
			ivec2( t % half_h, h - 1 - ( t % half_h ) );

		local_compare_and_swap(indices);
}

// Performs progressively diminishing disperse operations (starting with height h)
// on locally available indices: e.g. h==8 -> 8 : 4 : 2.
// One disperse operation for every time we can divide h by 2.
void local_disperse(in uint h){
	uint t = gl_LocalInvocationID.x;
	for ( ; h > 1 ; h /= 2 ) {
		
		barrier();

		uint half_h = h >> 1; // Note: h >> 1 is equivalent to h / 2 
		ivec2 indices = 
			ivec2( h * ( ( 2 * t ) / h ) ) +
			ivec2( t % half_h, half_h + ( t % half_h ) );

		local_compare_and_swap(indices);
	}
}

// Perform binary merge sort for local elements, up to a maximum number 
// of elements h.
void local_bms(uint h){
	uint t = gl_LocalInvocationID.x;
	for ( uint hh = 2; hh <= h; hh <<= 1 ) {  // note:  h <<= 1 is same as h *= 2
		local_flip( hh);
		local_disperse( hh/2 );
	}
}

// void cacheLocalValues(uint index, uint global_index) {
//     local_values[index] = values[global_index].positionAndLifeTime.y;
//     local_indices[index] = global_index;
    // local_values[index] = values[global_index];
// }

// void updateGlobalValues(uint index, uint global_index) {
//     values[global_index] = values[local_indices[index]];
// }

void main(){
	
	uint t = gl_LocalInvocationID.x;
 
 	// Calculate global offset for local workgroup
	uint offset = gl_WorkGroupSize.x * 2 * gl_WorkGroupID.x;

	// This shader can be called in four different modes:
    // 
	//  1. local flip+disperse (up to n == local_size_x * 2) 
	//  2. big flip
	//  3. big disperse
	//  4. local disperse 
    //
    // Which one to choose is communicated via parameters.algorithm

	if (parameters.algorithm <= eLocalDisperse){
		// In case this shader executes a `local_` algorithm, we must 
		// first populate the workgroup's local memory.
		//
		local_values[t*2]   = values[offset+t*2];
		local_values[t*2+1] = values[offset+t*2+1];
        // cacheLocalValues(t*2, offset+t*2);
        // cacheLocalValues(t*2+1, offset+t*2+1);
	}

	switch (parameters.algorithm){
		case eLocalBitonicMergeSortExample:
			local_bms(parameters.h);
		break;
		case eLocalDisperse:
			local_disperse(parameters.h);
		break;
		case eBigFlip:
			big_flip(parameters.h);
		break;
		case eBigDisperse:
			big_disperse(parameters.h);
		break;
	}

	// Write local memory back to buffer in case we pulled in the first place.
	//
	if (parameters.algorithm <= eLocalDisperse){
		barrier();
		// push to global memory
		values[offset+t*2]   = local_values[t*2];
		values[offset+t*2+1] = local_values[t*2+1];
        // values[offset + t * 2] = values[local_indices[t * 2]];
        // values[offset + t * 2 + 1] = values[local_indices[t * 2 + 1]];
	}


}